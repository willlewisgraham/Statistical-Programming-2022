---
title: "Project 1"
author: "Will Graham; Richelle Lee; Robin Lin"
date: '2022-10-06'
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
hess_with_finite_differencing <- function(current_theta, grad, eps){
  # This function uses finite differencing to approximate the hessian matrix
  # of an objective function with respect to a supplied parameter vector of 
  # thetas. 
  #
  # Inputs:
  # current_theta - a parameter vector that the hessian will be evaluated at
  # grad - the gradient function. Returns the gradient vector of the objective
  # w.r.t. the elements of parameter vector
  # 
  # Returns:
  # a Hessian matrix approximated with finite differencing
  
  delta <- eps # use a static delta for finite differencing
  
  # Calculate differences in gradient function
  grad_diff <- grad(current_theta + delta/2) - grad(current_theta - delta/2)
  
  # Repeat the gradient differences column m times, where m is the number of
  # thetas. The resulting matrix is now of size mxm
  grad_diff <- matrix(grad_diff, length(grad_diff), length(grad_diff))
  
  hess_approx <- grad_diff / delta # Approximate the Hessian matrix
  
  # Ensure Hessian approximation is symmetric
  hess_approx <- (t(hess_approx) + hess_approx) / 2 
  
return(hess_approx)
}

```

```{r}

newt <- function(theta, func, grad, hess = NULL, ..., tol = 1e-8, fscale = 1, maxit = 100, max.half = 20, eps = 1e-6){
  
  # if no hessian matrix function is supplied, default to finite differencing
  hess.supplied <- TRUE
  if(is.null(hess)){ 
    hess.supplied <- FALSE
  }
  
  obj_at_theta <- func(theta) # evaluate objective function at initial theta
  grad_at_theta <- grad(theta) # evaluate gradient at initial theta
  
  if(hess.supplied){
    hess_at_theta <- hess(theta) # evaluate hessian at inital theta
  } else {
    hess_at_theta <- hess_with_finite_differencing(theta, grad, eps)
  }
  

  # combine obj, gradient, and hessian values at theta into 1 vector
  obj_and_derivatives <- c(obj_at_theta, grad_at_theta, hess_at_theta)
  
  if (Inf %in% obj_and_derivatives | -Inf %in% obj_and_derivatives){
    stop("Objective Funciton or Derivatives Not Finite at Initial Theta")
  }

i = 0 # Tracks 
  while(i < maxit){
    obj_at_theta <- func(theta)
    grad_at_theta <- grad(theta)
    
    if(hess.supplied){
    hess_at_theta <- hess(theta) # evaluate hessian at inital theta
  } else {
    hess_at_theta <- hess_with_finite_differencing(theta, grad, eps)
  }
  
    
    if(sum(abs(grad_at_theta) < tol * abs(obj_at_theta) + fscale) == length(theta)){
      chol_of_hess <- try(chol(hess_at_theta), silent = TRUE)
      if(all(class(chol_of_hess) == 'try-error')){
        warning('Hessian is not positive definite at convergence.')
        return(list('f' = obj_at_theta, 'theta' = theta, 'iter' = i, 'g' = grad_at_theta, 'Hi' = "Hessian is not invertible"))
        
      }
      return(list('f' = obj_at_theta, 'theta' = theta, 'iter' = i, 'g' = grad_at_theta, 'Hi' = inv_hess))
    }
  
    eig_hess <- eigen(hess_at_theta) # Computes the eigen-decomposition on the     # hessian matrix.
      lambdas <- eig_hess$values # Identifies the lambdas from the                # eigen-decomposition.
      
      if(min(lambdas) <= 0){ # If the smallest value of the lambdas is smaller       # than zero,
        pert_hess_at_theta <- hess_at_theta + (-(min(lambdas)) + 1)*   diag(length(hess_at_theta)) # perturb the hessian matrix.
        
        eig_hess <- eigen(pert_hess_at_theta) # Computes the 
        # eigen-decomposition on the perturbed hessian matrix.
        lambdas <- eig_hess$values # Identifies the lambdas from the                  # eigen-decomposition of the perturbed hessian matrix.
      }  
      U <- eig_hess$vectors # Identifies the U from the eigen-decomposition of       # the hessian matrix or the perturbed hessian matrix
      
      inv_hess <- U %*% (diag(1/lambdas)) %*% t(U) # Calculates the inverse of       # the hessian matrix.
  
      descent_direction <- -inv_hess %*% grad_at_theta
      stepsize <- 1
      halves <- 0
      theta_hat <- theta +  stepsize * descent_direction
      
      
  while(obj_at_theta < func(theta_hat) && halves <= max.half){
      stepsize <- stepsize / 2
      theta_hat <- theta +  stepsize * descent_direction
      halves <- halves + 1
      
  }
  if(halves == (max.half + 1)){
    stop("Maximum number of step halvings reached")
  }
  theta <- theta_hat
  i <- i + 1
  
  }
  warning("Maximum iterations reached without convergence")
 ## CHECK FOR INVERSE HESSIAN
      return(list('f' = obj_at_theta, 'theta' = theta, 'iter' = i, 'g' = grad_at_theta, 'Hi' = inv_hess))
}
```

```{r}
rb <- function(th,k=2) {
k*(th[2]-th[1]^2)^2 + (1-th[1])^2
}
gb <- function(th,k=2) {
c(-2*(1-th[1])-k*4*th[1]*(th[2]-th[1]^2),k*2*(th[2]-th[1]^2))
}

hb <- function(th,k=2) {
h <- matrix(0,2,2)
h[1,1] <- 2-k*2*(2*(th[2]-th[1]^2) - 4*th[1]^2)
h[2,2] <- 2*k
h[1,2] <- h[2,1] <- -4*k*th[1]
h
}

theta = c(10,10)

test <- newt(theta, rb, gb, hb, 2)
```

```{r}
rb <- function(th) {
  th

}
gb <- function(th) {
  1
}

hb <- function(th) {
0
}

theta = c(10)

test <- newt(theta, rb, gb, hb, fscale = 0.5, maxit = 4)
```

```{r}
debug(newt)
newt(theta, rb, gb, hb, fscale = 0.5, maxit = 4)
undebug(newt)
```

